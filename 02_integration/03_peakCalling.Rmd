---
title: "Calling Peaks"
author: "kou"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,include=T,message=F)
```

```{r libraries, warning=F}
library(ArchR)
library(Signac)
library(Seurat)
library(SeuratObject)
library(tidyverse)
library(ggpubr)
library(shiny)
library(qs)
library(reticulate)
library(EnsDb.Hsapiens.v86)

# always set seed!!! need to repeat
set.seed(105)

options(future.globals.maxSize = 4000 * 1024^2)
addArchRThreads(threads = 64, force = T)
addArchRGenome("hg38")

# set python
use_python("/g/scb/zaugg/kou/projects/composite/analysis/sc_py_env/bin")
use_virtualenv("/g/scb/zaugg/kou/projects/composite/analysis/sc_py_env")
```

```{r load data}
sct_atac_combined = qread("02_integration/rds/02_sct_atac_combined_noCCreg.qs")
archR_keep = loadArchRProject("01_QC/ArchRproj_keep/")
```

## Peak calling with ArchR using MACS2

Liked ArchR's iterative peak overlap process on fixed with peaks, which prevents peaks from "daisy-chaining" into larger peaks and masking small peaks.

Need to first create an ArchR project with all samples/cells, and add cluster assignment and wnn embedding.

```{r add cluster, eval = F}
# check if cell order is the same
all(archR_keep$cellNames == sct_atac_combined$cell_ids)

# reorder to seurat to match archR
## TO DO: repeat by reordering ArchR to match Seurat
meta = sct_atac_combined@meta.data

ord = match(archR_keep$cellNames, meta$cell_ids)
meta = meta[ord,]

# add cluster info
archR_keep$wnn.cluster = meta$wsnn_res.0.8

# add wnn embedding
wnnUMAP = as_tibble(Embeddings(sct_atac_combined, reduction = "wnnUMAP"),
                    rownames = "CellIDs")

# reorder rownames to match archr proj
wnnUMAP = wnnUMAP[ord,]

# rename rows and cols to be consistent w archr
rownames(wnnUMAP) = gsub("_","#", rownames(wnnUMAP))
colnames(wnnUMAP) = paste0("seurLSI#",colnames(wnnUMAP))

archR_keep@embeddings$wnnUMAP = SimpleList(df = wnnUMAP, params = list())

# save for future loading
allLN = saveArchRProject(ArchRProj = archR_keep,
                         outputDirectory ="02_integration/allLN_ArchR", 
                         load = T)
```

```{r load archr proj}
allLN = loadArchRProject("02_integration/allLN_ArchR")
```

Call peaks using macs2 on pseudobulked replicates of wnn clusters identified in seurat.

```{r call peaks, eval=F}
h5disableFileLocking()

# get pseudobulk clusters
allLN = addGroupCoverages(
  ArchRProj = allLN, 
  groupBy = "wnn.cluster", 
  threads = 64,
  force = T
)

h5enableFileLocking()

# call peaks; next time do min cells = 50
allLN = addReproduciblePeakSet(
  ArchRProj = allLN,
  minCells = 25,
  groupBy = "wnn.cluster", 
  pathToMacs2 = "sc_py_env/bin/macs2",
  excludeChr = c("chrM","chrY"),
  threads = 1,
  force = T
)

# add peak matrix
allLN = addPeakMatrix(allLN)

# save project
allLN = saveArchRProject(ArchRProj = allLN,
                         outputDirectory ="02_integration/allLN_ArchR", 
                         load = T)
```

## Create `ChromatinAssay`

```{r create chromatin assay, eval=F}
# get SE
peakSE = getMatrixFromProject(allLN,"PeakMatrix")

# get counts in peaks, rename to match seurat obj
peakMat = assay(peakSE)
colnames(peakMat) = gsub("#","_",colnames(peakMat))

# get ranges of peaks
peakRanges = granges(peakSE)

# get metadata to add to seurat metadata (ie: Frac Reads in Peaks)
data = colData(peakSE)
rownames(data) = gsub("#","_",rownames(data))

# get annotation
hg38_anno = ArchRtoSignac::getAnnotation(reference = EnsDb.Hsapiens.v86, 
                                         refversion = "hg38",
                                         seqStyle = "UCSC")

# create chromatin assay
peakAssay = CreateChromatinAssay(counts = peakMat,
                                 ranges = peakRanges,
                                 genome = "hg38",
                                 min.cells = 50,
                                 annotation = hg38_anno,
                                 validate.fragments = F)

peakAssay@meta.features = as.data.frame(data)
```

## Add to large seurat object

Cells do not need to be reordered to be added into Seurat obj!

```{r add to large seurObj}
# add "PEAK" assay to seurat obj (to do: rename other assay to "TILE"?)
sct_atac_combined[["PEAKS"]] = peakAssay

# remove redudant columns before adding to metadata
data = data[, colnames(data) %ni% c("Sample","wnn.cluster")]

# reorder
## first checked that all(rownames(sct_atac_combined@meta.data) == Cells(sct_atac_combined))
ord = match(Cells(sct_atac_combined), rownames(data))
data = data[ord,]

# add to metadata
sct_atac_combined@meta.data = cbind(sct_atac_combined@meta.data, data)

# save and analyze in separate script
qsave(sct_atac_combined,"02_integration/rds/03_sct_atac_combined.qs", nthreads = 64)
```
