---
title: "Peak Calling, Motif Enrichment, and (new) Gene Score Activity"
author: "kou"
date: "`r Sys.Date()`"
output:
  html_document:
  toc: true
  toc_float: true
  toc_collapsed: true
toc_depth: 3
number_sections: true
theme: cosmo
runtime: shiny
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,include=T,message=F)
```

```{r libraries, warning=F}
library(ArchR)
library(Signac)
library(Seurat)
library(SeuratObject)
library(tidyverse)
library(ggpubr)
library(shiny)
library(qs)
library(reticulate)
library(EnsDb.Hsapiens.v86)
library(MotifDb)
library(universalmotif)
library(BSgenome.Hsapiens.UCSC.hg38)
library(TFBSTools)
library(BiocParallel)
library(chromVAR)

# always set seed!!!
set.seed(105)

options(future.globals.maxSize = 4000 * 1024^2)
addArchRThreads(threads = 125, force = T)
addArchRGenome("hg38")

# set python
use_python("/g/scb/zaugg/kou/projects/composite/analysis/sc_py_env/bin")
use_virtualenv("/g/scb/zaugg/kou/projects/composite/analysis/sc_py_env")
```

```{r load data}
sct_atac_combined = qread("02_integration/rds/02_sct_atac_combined_noCCreg.qs")
archR_keep = loadArchRProject("01_QC/ArchRproj_keep/")
```

This script uses ArchR wrappers to identify Peaks, impute weights, Motif Deviations, and Gene Score Activity. These results are then inserted as individual "Assays" into the integrated `Large SeuratObject`.

## Peak calling using MACS2

Liked ArchR's iterative peak overlap process on fixed with peaks, which prevents peaks from "daisy-chaining" into larger peaks and masking small peaks.

Need to first create an ArchR project with all samples/cells, and add cluster assignment and wnn embedding.

```{r addCluster}
# check if cell order is the same
all(archR_keep$cellNames == sct_atac_combined$cell_ids)

# reorder to seurat to match archR
## TO DO: repeat by reordering ArchR to match Seurat
meta = sct_atac_combined@meta.data

ord = match(archR_keep$cellNames, meta$cell_ids)
meta = meta[ord,]

# add cluster info
archR_keep$wnn.cluster = meta$wsnn_res.0.8

# add wnn embedding
wnnUMAP = Embeddings(sct_atac_combined, reduction = "wnnUMAP")

# reorder rownames (same as original seurat@meta.data) to match archr proj
wnnUMAP = wnnUMAP[ord,]

# rename rows and cols to be consistent w archr
rownames(wnnUMAP) = gsub("_","#", rownames(wnnUMAP))
colnames(wnnUMAP) = paste0("seurLSI#",colnames(wnnUMAP))

archR_keep@embeddings$wnnUMAP = SimpleList(df = wnnUMAP, params = list())

# save for future loading
allLN = saveArchRProject(ArchRProj = archR_keep,
                         outputDirectory ="02_integration/allLN_ArchR", 
                         load = T)
```

```{r loadArchrProj, eval=F}
allLN = loadArchRProject("02_integration/allLN_ArchR")
```

Call peaks using macs2 on pseudobulked replicates of wnn clusters identified in Seurat.

```{r callPeaks}
h5disableFileLocking()

# get pseudobulk clusters
allLN = addGroupCoverages(
  ArchRProj = allLN, 
  groupBy = "wnn.cluster", 
  threads = 125,
  force = T
)

h5enableFileLocking()

# call peaks
## TO DO: next time do min cells = 50
allLN = addReproduciblePeakSet(
  ArchRProj = allLN,
  minCells = 25,
  groupBy = "wnn.cluster", 
  pathToMacs2 = "sc_py_env/bin/macs2",
  excludeChr = c("chrM","chrY"),
  threads = 1,
  force = T
)

# add peak matrix
allLN = addPeakMatrix(allLN)

# save project
allLN = saveArchRProject(ArchRProj = allLN,
                         outputDirectory ="02_integration/allLN_ArchR", 
                         load = T)
```

## Motif deviations with ChromVAR

ChromVAR aggregates all peaks to identify enriched TF activity (over GC corrected background) at single cell level. First need to annotate motifs in peaks, then perform TF deviation score calculation.

### Motif databases: JASPAR2022 and HOCOMOCO

First queried `MotifDb` object to determine which database to use. In this analysis, I'll use human data from JASPAR2022 and HOCOMOCOv11.

**IMPORTANT** MotifDb supplies position *frequency* matrices (ie: columns/positions add to 1)!! Will need to convert to position *weight* matrices as input for ArchR using `universalmotif` package.

**JASPAR**:

-   (from website) The motifs in JASPAR are collected in two ways:

    -   **Internally:** *de novo* generated motifs, by analyzing ChIP-seq/-exo sequences using a custom motif discovery pipeline (check the code at our [repository](https://bitbucket.org/CBGR/jaspar_2022_motif_discovery_and_curation_pipeline/src/master/)).

    -   **Externally:** motifs taken directly from other publications and/or resources.

**HOCOMOCO**:

-   \<TO DO: add description\>

```{r motifdb}
# get PFM matrices
jaspar2022=query(MotifDb, andStrings=c("hsapiens","jaspar2022"))
hocomocoV11=query(MotifDb, andStrings=c("hsapiens","HOCOMOCOv11"))

# can access additional information w/ mcols
jaspar_meta = mcols(jaspar2022)
hoco_meta = mcols(hocomocoV11)

# check to see that PAX5, BCL6, and other TFs are in the databases
tfsOfI = c("PAX5","TCF7","BCL6","IRF8","IRF4","FOX")

tfsInJaspar = names(jaspar2022)[grep(str_c(tfsOfI, collapse = "|"), names(jaspar2022))]

tfsInHoco = names(hocomocoV11)[grep(str_c(tfsOfI, collapse = "|"), names(hocomocoV11))]

sort(tfsInJaspar)
sort(tfsInHoco)
```

Both seem to cover (super brief list of) TFs in interest. There are differences in the PFM however.\
Example: FOXP3

```{r FOXP3pfm, eval=F}
# example: FOXP3 PFM in jaspar
jaspar2022[[grep("-FOXP3-",names(jaspar2022))]]

# example: FOXP3 PFM in hoco
hocomocoV10[[grep("-FOXP3_",names(hocomocoV10))]]
```

Want to include both lists because of these differences. First tidied names of each element in list, subsetted (in case of HOCOMOCO), then combined into master list before converting to PWM.

**JASPAR nomenclature:**

-   ex: "Hsapiens-jaspar2022-PPARG-MA0066.1"

-   `<TF name>`-`<BaseID, starts with MA>`.`<version>`

-   MatrixID of the TF = \<BaseID\>.\<version\>

-   if BaseID / MatrixID starts with "UN", it is unverified. Already checked that all motifs are verified.

**HOCOMOCO nomenclature:**

-   ex: "Hsapiens-HOCOMOCOv11-core-C-AIRE_HUMAN.H11MO.0.C"

-   `<core vs secondary>`-`<quality score A-D>`-`<TF name>`\_`<species>`.`<model>`.`<rank>`.`<quality score>`

-   Core vs Secondary: "We additionally introduced the secondary (mostly single-box) models with the special S quality to distinguish them in the collection (thus allowing two models for the same TF). The S models were included for 40 (31) human (mouse) TFs when 2 distinct cases were curated in HOCOMOCO v9, or when a new primary model resembled a notably longer or different pattern (e.g. double-box)."

    -   Can tell if it's core or secondary based on Rank. Core always has rank 0. Secondary has rank 1 or 2.

-   Quality: "Each model in the collection has a quality rating from A to D where A represents motifs with the highest confidence, and models down to C quality are suitable for quantitative analyses. A motif of D quality provides only rough description of a binding pattern and should be used primarily in exploration studies. The details on quality assignment can be found in the most recent HOCOMOCO paper."

-   Model: Version, mononucleotude (MO) vs dinucleotide (DI). All models present are H11MO which is mononucleotide.

-   Rank: "Since v11 the alternative binding models of a particular TF are ranked from 0 (the primary model) to 1 and 2 (the alternative models, including single-box variants). The models of 0 rank is the most 'general' variant with the best weighted performance in the cross-validation benchmark (see the HOCOMOCO paper for details)."

```{r finalMotifList}
# tidy jaspar, want TF-unique/matID_db
## use different separators, easier to separate later for plotting, etc
names(jaspar2022) = gsub("Hsapiens.*jaspar2022-","",names(jaspar2022)) %>% 
  paste0(.,"_jaspar2022")

## change rownames of elementMetadata
rownames(jaspar2022@elementMetadata) = names(jaspar2022)

# tidy hoco
## subset hocomoco w/ qualities A-C only
hoco_ABC = hocomocoV11[!grepl(".D$",names(hocomocoV11))]

## tidy hoco names
names(hoco_ABC) = gsub("Hsapiens.*-[A-C]-|HUMAN.","",names(hoco_ABC)) %>%
  gsub("_","-",.) %>%
  paste0(.,"_hocoV11")

## change rownames of elementMetadata
rownames(hoco_ABC@elementMetadata) = names(hoco_ABC)

# combine list, convert into universalmotif class, save bc metadata is useful
finalMotif = c(jaspar2022,hoco_ABC)
qsave(finalMotif, "02_integration/rds/03_finalMotif.qs", nthreads = 16)
```

```{r loadpwm, eval=F}
finalMotif = qread("02_integration/rds/03_finalMotif.qs")
```

### Motif Annotation

Annotate peaks with motifs contained in PWM list.
```{r peakAnno}
# convert to PWM
finalPWM = convert_motifs(finalMotif, class = "TFBSTools-PWMatrix")
finalPWM = do.call(PWMatrixList,finalPWM)
names(finalPWM) = names(finalMotif)

# add motif annotations to peak
allLN = addMotifAnnotations(allLN, 
                            motifPWMs = finalPWM,
                            motifSet = NULL,
                            collection = NULL,
                            annoName = "Motif",
                            force = F)

# add background peaks
allLN = addBgdPeaks(allLN)

# save project
allLN = saveArchRProject(ArchRProj = allLN,
                         outputDirectory ="02_integration/allLN_ArchR", 
                         load = T)

```

### ChromVAR

Add motif deviation score to ArchR project.

Note: the Signac/Seurat wrapper is NOT very good! would need to use BiocParallel and/or submit to hpc.
TO DO: REPEAT when more space on seneca, or submit to cluster?! 

```{r chromvar}
# add deviations
allLN = addDeviationsMatrix(ArchRProj = allLN, 
                            peakAnnotation = "Motif",
                            threads = 1,
                            force = T)

# save project! 
allLN = saveArchRProject(ArchRProj = allLN,
                         outputDirectory ="02_integration/allLN_ArchR", 
                         load = T)
```

```{r eval=F}
allLN = loadArchRProject("02_integration/allLN_ArchR")
```

Test plotting

```{r eval=F}
wnnUMAP = getEmbedding(allLN,"wnnUMAP")

plotEmbedding(allLN,
              embedding = "wnnUMAP",
              colorBy = "motifMatrix",
              name = c("z:PAX6-H11MO.0.C_hocoV11","z:IRF8-H11MO.0.B_hocoV11"))
```

## TO DO: Gene score activity with combined cells


## Integrating data to Seurat Object
FYI: Cells do not need to be reordered to be added into Seurat obj!

### Adding Peaks
```{r createChromatinAssay, eval=F}
# get SE
peakSE = getMatrixFromProject(allLN,"PeakMatrix")

# get counts in peaks, rename to match seurat obj
peakMat = assay(peakSE)
colnames(peakMat) = gsub("#","_",colnames(peakMat))

# get ranges of peaks; idx is index of chr
peakRanges = granges(peakSE)

# get metadata to add to seurat metadata (ie: Frac Reads in Peaks)
data = colData(peakSE)
rownames(data) = gsub("#","_",rownames(data))

# get annotation
hg38_anno = ArchRtoSignac::getAnnotation(reference = EnsDb.Hsapiens.v86, 
                                         refversion = "hg38",
                                         seqStyle = "UCSC")

# create chromatin assay
peakAssay = CreateChromatinAssay(counts = peakMat,
                                 ranges = peakRanges,
                                 genome = "hg38",
                                 min.cells = 0,
                                 annotation = hg38_anno,
                                 validate.fragments = F)

peakAssay@meta.features = as.data.frame(data)

# add "peaks" assay to seurat obj (TO DO: rename other assay to "tile"?)
sct_atac_combined[["peaks"]] = peakAssay

# remove redundant columns before adding to metadata
data = data[, colnames(data) %ni% c("Sample","wnn.cluster")]

# reorder
## first checked that all(rownames(sct_atac_combined@meta.data) == Cells(sct_atac_combined))
ord = match(Cells(sct_atac_combined), rownames(data))
data = data[ord,]

# add to metadata
sct_atac_combined@meta.data = cbind(sct_atac_combined@meta.data, data)
```
### Adding motif data to peaks assay
```{r addMotifObject, eval=F}
# get peak annotation info from ArchR project
peakAnno = getPeakAnnotation(allLN, "Motif")

# get granges list of motif positions
positions = readRDS(peakAnno$Positions)

# get motif info in peaks
matchesSE = readRDS(peakAnno$Matches)

# get binarized matrix of peaks (rows) vs motif (cols)
motifMat = assay(matchesSE)

# rename rownames
rownames(motifMat) = GRangesToString(matchesSE@rowRanges)

# get granges containing metadata of peakset; previously checked if same as peakRanges
peakMetadata = as.data.frame(matchesSE@rowRanges, row.names = GRangesToString(matchesSE@rowRanges))

# create motif object
motifObj = CreateMotifObject(
  data = motifMat,
  pwm = allLN@peakAnnotation$Motif$motifs,
  motif.names = names(allLN@peakAnnotation$Motif$motifs),
  positions = positions,
  meta.data = peakMetadata
)

# add motif object to peaks seurat object
DefaultAssay(sct_atac_combined) = "peaks"
Motifs(sct_atac_combined) = motifObj

# save and analyze in separate script
qsave(sct_atac_combined,"02_integration/rds/03_sct_atac_combined.qs", nthreads = 64)
```

### Adding chromvar assay to seurat object
```{r addchromvar}
# get chromvar data
motifDevSE = getMatrixFromProject(allLN, "MotifMatrix", verbose = F)
motifDevMat = assay(motifDevSE)
colnames(motifDevMat) = gsub("#","_",colnames(motifDevMat))

# get motif metadata, though not needed here
motifDevMetadata = finalMotif@elementMetadata

# create seurat obj
sct_atac_combined[["chromVAR"]] = CreateAssayObject(data = motifDevMat)

# save and analyze in separate script
qsave(sct_atac_combined,"02_integration/rds/03_sct_atac_combined.qs", nthreads = 64)
```

test plot
```{r}
DefaultAssay(sct_atac_combined) = "chromVAR"

FeaturePlot(
  object = sct_atac_combined,
  features = "PAX5-H11MO.0.A-hocoV11",
  pt.size = 0.1,
  min.cutoff = "q10",
  max.cutoff = "q90",
  reduction = "wnnUMAP"
) + 
  theme(aspect.ratio = 3/3) + 
  scale_color_viridis_c(option = "plasma")

```


